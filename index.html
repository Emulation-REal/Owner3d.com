<!DOCTYPE html>
<html>
<head>
    <title>Advanced 3D Shooter - Shipment</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="white"/><line x1="10" y1="2" x2="10" y2="6" stroke="white" stroke-width="1"/><line x1="10" y1="14" x2="10" y2="18" stroke="white" stroke-width="1"/><line x1="2" y1="10" x2="6" y2="10" stroke="white" stroke-width="1"/><line x1="14" y1="10" x2="18" y2="10" stroke="white" stroke-width="1"/></svg>');
            pointer-events: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
    <div id="crosshair"></div>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Player controls
        const controls = new THREE.PointerLockControls(camera, document.body);
        scene.add(controls.getObject());
        camera.position.set(0, 1.6, 0); // Eye level

        // Lock pointer on click
        document.addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => console.log('Pointer locked'));
        controls.addEventListener('unlock', () => console.log('Pointer unlocked'));

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Ground (Shipment floor)
        const groundGeometry = new THREE.PlaneGeometry(44, 32); // Shipment dimensions (scaled down)
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Containers (mimicking Shipment's layout)
        const containerGeometry = new THREE.BoxGeometry(12, 2.5, 2.5);
        const containerMaterial = new THREE.MeshStandardMaterial({ color: 0x4682b4, roughness: 0.7, metalness: 0.3 });
        const containers = [
            // Outer perimeter
            { pos: [0, 1.25, 15], rot: [0, 0, 0] }, // North
            { pos: [0, 1.25, -15], rot: [0, 0, 0] }, // South
            { pos: [20, 1.25, 0], rot: [0, Math.PI / 2, 0] }, // East
            { pos: [-20, 1.25, 0], rot: [0, Math.PI / 2, 0] }, // West
            // Central containers
            { pos: [5, 1.25, 0], rot: [0, 0, 0] }, // Center 1
            { pos: [-5, 1.25, 0], rot: [0, 0, 0] }, // Center 2
            { pos: [0, 1.25, 5], rot: [0, Math.PI / 2, 0] } // Center 3
        ];
        const containerMeshes = containers.map(c => {
            const mesh = new THREE.Mesh(containerGeometry, containerMaterial);
            mesh.position.set(...c.pos);
            mesh.rotation.set(...c.rot);
            scene.add(mesh);
            return mesh;
        });

        // Bots
        const botGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
        const botMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.9 });
        const bots = [];
        const botSpawns = [
            [15, 0.9, 10], [-15, 0.9, -10], [10, 0.9, -12], [-10, 0.9, 12]
        ];
        for (let i = 0; i < 4; i++) {
            const bot = new THREE.Mesh(botGeometry, botMaterial);
            bot.position.set(...botSpawns[i]);
            bot.health = 100;
            bot.speed = 0.05 + Math.random() * 0.03;
            scene.add(bot);
            bots.push(bot);
        }

        // Gun model
        const gunGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.5);
        const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.position.set(0.3, -0.3, -0.5);
        camera.add(gun);
        scene.add(camera);

        // Bullets
        const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const bulletMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00 });
        const bullets = [];

        // Keyboard controls
        const keys = {};
        document.addEventListener('keydown', e => keys[e.code] = true);
        document.addEventListener('keyup', e => keys[e.code] = false);

        // Shooting
        let lastShot = 0;
        const fireRate = 0.2; // Seconds between shots
        document.addEventListener('mousedown', () => {
            if (controls.isLocked && performance.now() - lastShot > fireRate * 1000) {
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                bullet.position.copy(camera.position);
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                bullet.velocity = direction.clone().multiplyScalar(50);
                scene.add(bullet);
                bullets.push(bullet);
                lastShot = performance.now();
            }
        });

        // Movement and collision
        let moveSpeed = 0.1;
        const sprintSpeed = 0.2;
        const playerBox = new THREE.Box3();
        const containerBoxes = containerMeshes.map(c => new THREE.Box3().setFromObject(c));
        const botBoxes = bots.map(bot => new THREE.Box3().setFromObject(bot));

        function update() {
            // Sprinting
            moveSpeed = keys['ShiftLeft'] ? sprintSpeed : 0.1;

            // Player movement
            const direction = new THREE.Vector3();
            if (keys['KeyW']) direction.z -= 1;
            if (keys['KeyS']) direction.z += 1;
            if (keys['KeyA']) direction.x -= 1;
            if (keys['KeyD']) direction.x += 1;
            direction.normalize().multiplyScalar(moveSpeed);
            const newPosition = camera.position.clone().add(direction);

            // Collision detection with containers
            playerBox.setFromCenterAndSize(newPosition, new THREE.Vector3(0.8, 1.8, 0.8));
            let canMove = true;
            for (let containerBox of containerBoxes) {
                if (playerBox.intersectsBox(containerBox)) {
                    canMove = false;
                    break;
                }
            }
            if (canMove) controls.getObject().position.copy(newPosition);

            // Bot AI with pathfinding avoidance
            bots.forEach(bot => {
                if (bot.health <= 0) return;
                const directionToPlayer = camera.position.clone().sub(bot.position).normalize();
                const moveVector = directionToPlayer.clone().multiplyScalar(bot.speed);
                const newBotPos = bot.position.clone().add(moveVector);
                const botBox = new THREE.Box3().setFromCenterAndSize(newBotPos, new THREE.Vector3(0.8, 1.8, 0.8));
                let botCanMove = true;
                for (let containerBox of containerBoxes) {
                    if (botBox.intersectsBox(containerBox)) {
                        botCanMove = false;
                        break;
                    }
                }
                if (botCanMove) bot.position.copy(newBotPos);
                bot.lookAt(camera.position);
            });

            // Bullet movement and collision
            bullets.forEach((bullet, index) => {
                bullet.position.add(bullet.velocity.clone().multiplyScalar(1/60));
                const bulletBox = new THREE.Box3().setFromObject(bullet);
                bots.forEach(bot => {
                    if (bot.health <= 0) return;
                    const botBox = new THREE.Box3().setFromObject(bot);
                    if (bulletBox.intersectsBox(botBox)) {
                        bot.health -= 20;
                        scene.remove(bullet);
                        bullets.splice(index, 1);
                        if (bot.health <= 0) {
                            bot.material.color.set(0x555555);
                        }
                    }
                });
                if (bullet.position.length() > 100) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start game loop
        update();
    </script>
</body>
</html>
